import json
import os
from typing import List, Dict, Optional
import logging

logger = logging.getLogger(__name__)

class CaptionStyleManager:
    """
    Manages different caption styles and word-by-word highlighting effects
    """

    CAPTION_STYLES = {
        'modern_purple': {
            'name': 'Modern Purple',
            'font': 'Arial-Bold',
            'font_size': 24,
            'font_size_vertical': 18,  # Smaller for vertical videos
            'primary_color': 'white',
            'highlight_color': '#8B5CF6',  # Purple
            'outline_color': 'black',
            'outline_width': 2,
            'position': 'bottom',
            'animation': 'word_highlight',
            'background': 'semi_transparent'
        },
        'tiktok_style': {
            'name': 'TikTok Style',
            'font': 'Arial-Black',
            'font_size': 28,
            'primary_color': 'white',
            'highlight_color': '#FF6B6B',  # Red/Pink
            'outline_color': 'black',
            'outline_width': 3,
            'position': 'center',
            'animation': 'bounce_highlight',
            'background': 'none'
        },
        'youtube_style': {
            'name': 'YouTube Style',
            'font': 'Roboto-Bold',
            'font_size': 22,
            'primary_color': 'white',
            'highlight_color': '#FFD700',  # Gold
            'outline_color': 'black',
            'outline_width': 1,
            'position': 'bottom',
            'animation': 'fade_highlight',
            'background': 'black_box'
        },
        'instagram_story': {
            'name': 'Instagram Story',
            'font': 'Helvetica-Bold',
            'font_size': 26,
            'primary_color': 'white',
            'highlight_color': '#E91E63',  # Pink
            'outline_color': 'none',
            'outline_width': 0,
            'position': 'center',
            'animation': 'scale_highlight',
            'background': 'gradient_box'
        },
        'podcast_style': {
            'name': 'Podcast Style',
            'font': 'Georgia',
            'font_size': 20,
            'primary_color': 'white',
            'highlight_color': '#4CAF50',  # Green
            'outline_color': 'black',
            'outline_width': 1,
            'position': 'bottom',
            'animation': 'underline_highlight',
            'background': 'dark_semi_transparent'
        }
    }

    def __init__(self, style_name: str = 'modern_purple', output_format: str = 'horizontal'):
        self.style = self.CAPTION_STYLES.get(style_name, self.CAPTION_STYLES['modern_purple'])
        self.style_name = style_name
        self.output_format = output_format

    def create_word_level_ass(self, segments: List[Dict], output_path: str) -> str:
        """
        Create ASS file with proper word highlighting (better than SRT for styling)
        """
        try:
            # Change extension to .ass
            ass_output_path = output_path.replace('.srt', '.ass')

            with open(ass_output_path, 'w', encoding='utf-8') as f:
                # Write ASS header
                f.write("[Script Info]\n")
                f.write("Title: Generated by Video Clipper\n")
                f.write("ScriptType: v4.00+\n\n")

                f.write("[V4+ Styles]\n")
                f.write("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n")

                # Define style based on caption style (with proper color support)
                if self.style_name == 'modern_purple':
                    # Get font size based on format - use smaller font for vertical videos
                    if self.output_format == 'vertical':
                        font_size = self.style.get('font_size_vertical', 18)
                    else:
                        font_size = self.style['font_size']
                    # Style: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
                    f.write(f"Style: Default,Arial,{font_size},&HFFFFFF,&HFFFFFF,&H000000,&H80000000,0,0,0,0,100,100,0,0,1,2,1,2,30,30,20,1\n\n")
                elif self.style_name == 'tiktok_style':
                    f.write("Style: Default,Arial,28,&HFFFFFF,&HFFFFFF,&H000000,&H80000000,1,0,0,0,100,100,0,0,1,3,1,2,30,30,20,1\n\n")
                else:
                    f.write("Style: Default,Arial,24,&HFFFFFF,&HFFFFFF,&H000000,&H80000000,0,0,0,0,100,100,0,0,1,2,1,2,30,30,20,1\n\n")

                f.write("[Events]\n")
                f.write("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n")

                for segment in segments:
                    text = segment["text"].strip()
                    if not text:
                        continue

                    # Check if this style needs word highlighting AND has word-level timestamps
                    if self._needs_word_highlighting() and "words" in segment:
                        # Use REAL Whisper word-level timestamps
                        words_data = segment["words"]
                        all_words = [w["word"].strip() for w in words_data]

                        # DEBUG: Log word-level data
                        logger.info(f"Processing segment with {len(words_data)} words: {[w['word'] for w in words_data[:5]]}")
                        if words_data:
                            logger.info(f"First word timing: {words_data[0]['start']:.2f}s - {words_data[0]['end']:.2f}s")

                        for i, word_data in enumerate(words_data):
                            word_text = word_data["word"].strip()
                            if not word_text:
                                continue

                            # Use actual Whisper word timestamps
                            word_start = word_data["start"]
                            word_end = word_data["end"]

                            # Ensure minimum display time (0.5s)
                            if word_end - word_start < 0.5:
                                word_end = word_start + 0.5

                            # Format ASS timestamps
                            start_time = self._format_ass_timestamp(word_start)
                            end_time = self._format_ass_timestamp(word_end)

                            # Create highlighted text with ASS formatting
                            highlighted_text = self._create_highlighted_phrase_ass(all_words, i)

                            f.write(f"Dialogue: 0,{start_time},{end_time},Default,,0,0,0,,{highlighted_text}\n")
                    else:
                        # Use simple segment-level timing
                        start_time = self._format_ass_timestamp(segment["start"])
                        end_time = self._format_ass_timestamp(segment["end"])

                        f.write(f"Dialogue: 0,{start_time},{end_time},Default,,0,0,0,,{text}\n")

            logger.info(f"Created ASS subtitle file with {self.style_name} style: {ass_output_path}")

            # DEBUG: Log first few lines of ASS file to verify content
            try:
                with open(ass_output_path, 'r', encoding='utf-8') as debug_file:
                    lines = debug_file.readlines()
                    logger.info(f"ASS file preview (first 10 lines):")
                    for i, line in enumerate(lines[:10]):
                        logger.info(f"Line {i+1}: {line.strip()}")

                    # Log some dialogue lines specifically
                    dialogue_lines = [line for line in lines if line.startswith('Dialogue:')]
                    if dialogue_lines:
                        logger.info(f"Sample dialogue lines:")
                        for i, dialogue in enumerate(dialogue_lines[:3]):
                            logger.info(f"Dialogue {i+1}: {dialogue.strip()}")
            except Exception as debug_error:
                logger.warning(f"Could not debug ASS file: {debug_error}")

            return ass_output_path

        except Exception as e:
            logger.error(f"Failed to create ASS subtitle: {e}")
            raise

    def create_word_level_srt(self, segments: List[Dict], output_path: str) -> str:
        """
        Create SRT file with proper timing - word highlighting for supported styles
        """
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                subtitle_index = 1

                for segment in segments:
                    text = segment["text"].strip()
                    if not text:
                        continue

                    # Check if this style needs word highlighting AND has word-level timestamps
                    if self._needs_word_highlighting() and "words" in segment:
                        # Use REAL Whisper word-level timestamps (no more guessing!)
                        words_data = segment["words"]
                        all_words = [w["word"].strip() for w in words_data]

                        for i, word_data in enumerate(words_data):
                            word_text = word_data["word"].strip()
                            if not word_text:
                                continue

                            # Use actual Whisper word timestamps
                            word_start = word_data["start"]
                            word_end = word_data["end"]

                            # Ensure minimum display time (0.5s)
                            if word_end - word_start < 0.5:
                                word_end = word_start + 0.5

                            start_time = self._format_timestamp(word_start)
                            end_time = self._format_timestamp(word_end)

                            # Create highlighted text with accurate timing
                            highlighted_text = self._create_highlighted_phrase(all_words, i)

                            f.write(f"{subtitle_index}\n")
                            f.write(f"{start_time} --> {end_time}\n")
                            f.write(f"{highlighted_text}\n\n")

                            subtitle_index += 1
                    else:
                        # Use simple segment-level timing for other styles
                        start_time = self._format_timestamp(segment["start"])
                        end_time = self._format_timestamp(segment["end"])
                        styled_text = self._create_segment_styled_text(text)

                        f.write(f"{subtitle_index}\n")
                        f.write(f"{start_time} --> {end_time}\n")
                        f.write(f"{styled_text}\n\n")

                        subtitle_index += 1

            logger.info(f"Created SRT with {self.style_name} style: {output_path}")
            return output_path

        except Exception as e:
            logger.error(f"Failed to create SRT: {e}")
            raise

    def _create_highlighted_text(self, words: List[str], highlight_index: int) -> str:
        """
        Create text with the current word highlighted based on selected style
        """
        result_words = []

        for i, word in enumerate(words):
            if i == highlight_index:
                # Highlight current word based on style
                if self.style['animation'] == 'word_highlight':
                    highlighted_word = f'<font color="{self.style["highlight_color"]}">{word}</font>'
                elif self.style['animation'] == 'bounce_highlight':
                    highlighted_word = f'<font color="{self.style["highlight_color"]}" size="+2">{word}</font>'
                elif self.style['animation'] == 'fade_highlight':
                    highlighted_word = f'<font color="{self.style["highlight_color"]}">{word}</font>'
                elif self.style['animation'] == 'scale_highlight':
                    highlighted_word = f'<font color="{self.style["highlight_color"]}" size="+1"><b>{word}</b></font>'
                elif self.style['animation'] == 'underline_highlight':
                    highlighted_word = f'<u><font color="{self.style["highlight_color"]}">{word}</font></u>'
                else:
                    highlighted_word = f'<font color="{self.style["highlight_color"]}">{word}</font>'

                result_words.append(highlighted_word)
            else:
                # Non-highlighted words
                result_words.append(f'<font color="{self.style["primary_color"]}">{word}</font>')

        return " ".join(result_words)

    def _create_segment_styled_text(self, text: str) -> str:
        """
        Create styled text for segment-level display (no word-by-word highlighting)
        This fixes timing issues and subtitle glitching
        """
        # Apply style-specific formatting
        if self.style_name == 'modern_purple':
            # Purple style with white text and purple accent
            return f'<font color="{self.style["primary_color"]}" face="{self.style["font"]}">{text}</font>'

        elif self.style_name == 'tiktok_style':
            # Bold TikTok style
            return f'<font color="{self.style["primary_color"]}" face="{self.style["font"]}" size="+2"><b>{text}</b></font>'

        elif self.style_name == 'youtube_style':
            # YouTube style with background
            return f'<font color="{self.style["primary_color"]}" face="{self.style["font"]}">{text}</font>'

        elif self.style_name == 'instagram_story':
            # Instagram style with emphasis
            return f'<font color="{self.style["primary_color"]}" face="{self.style["font"]}" size="+1"><b>{text}</b></font>'

        elif self.style_name == 'podcast_style':
            # Clean podcast style
            return f'<font color="{self.style["primary_color"]}" face="{self.style["font"]}">{text}</font>'

        else:
            # Default styling
            return f'<font color="{self.style["primary_color"]}">{text}</font>'

    def _needs_word_highlighting(self) -> bool:
        """
        Determine which styles should use word highlighting
        """
        # Only modern_purple and youtube_style get word highlighting for now
        highlighting_styles = ['modern_purple', 'youtube_style']
        return self.style_name in highlighting_styles

    def create_simple_srt(self, segments: List[Dict], output_path: str) -> str:
        """
        Fallback method: Create simple segment-level SRT (no word highlighting)
        Use this if word-level highlighting is causing issues
        """
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                subtitle_index = 1

                for segment in segments:
                    text = segment["text"].strip()
                    if not text:
                        continue

                    start_time = self._format_timestamp(segment["start"])
                    end_time = self._format_timestamp(segment["end"])
                    styled_text = self._create_segment_styled_text(text)

                    f.write(f"{subtitle_index}\n")
                    f.write(f"{start_time} --> {end_time}\n")
                    f.write(f"{styled_text}\n\n")

                    subtitle_index += 1

            logger.info(f"Created simple SRT with {self.style_name} style: {output_path}")
            return output_path

        except Exception as e:
            logger.error(f"Failed to create simple SRT: {e}")
            raise

    def _create_highlighted_phrase(self, words: List[str], highlight_index: int) -> str:
        """
        Create full phrase with one word highlighted using ASS format for better compatibility
        """
        result_words = []

        for i, word in enumerate(words):
            if i == highlight_index:
                # Highlight current word with style-specific color using ASS tags
                if self.style_name == 'modern_purple':
                    # Use ASS color tags for purple highlighting
                    highlighted_word = f'{{\\c&H8B5CF6&\\b1}}{word}{{\\b0}}'
                elif self.style_name == 'youtube_style':
                    # Use ASS color tags for gold highlighting
                    highlighted_word = f'{{\\c&HFFD700&\\b1}}{word}{{\\b0}}'
                else:
                    highlighted_word = f'{{\\c&H8B5CF6&\\b1}}{word}{{\\b0}}'
                result_words.append(highlighted_word)
            else:
                # Non-highlighted words in white
                result_words.append(word)

        return " ".join(result_words)

    def _create_highlighted_phrase_ass(self, words: List[str], highlight_index: int) -> str:
        """
        Create full phrase with one word highlighted using proper ASS format
        """
        result_words = []

        for i, word in enumerate(words):
            if i == highlight_index:
                # Highlight current word with ASS color tags (BGR format)
                if self.style_name == 'modern_purple':
                    # Purple #8B5CF6 = RGB(139,92,246) = BGR(246,92,139) = &HF65C8B&
                    # Use proper purple color in BGR format
                    highlighted_word = f'{{\\c&HF65C8B&\\b1}}{word}{{\\c&HFFFFFF&\\b0}}'
                elif self.style_name == 'youtube_style':
                    # Gold #FFD700 = RGB(255,215,0) = BGR(0,215,255) = &H00D7FF&
                    highlighted_word = f'{{\\c&H00D7FF&\\b1}}{word}{{\\c&HFFFFFF&\\b0}}'
                else:
                    highlighted_word = f'{{\\c&HF65C8B&\\b1}}{word}{{\\c&HFFFFFF&\\b0}}'
                result_words.append(highlighted_word)
            else:
                # Non-highlighted words stay white
                result_words.append(word)

        return " ".join(result_words)

    def _format_ass_timestamp(self, seconds: float) -> str:
        """Convert seconds to ASS timestamp format (H:MM:SS.CC)"""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        centiseconds = int((seconds % 1) * 100)
        return f"{hours}:{minutes:02d}:{secs:02d}.{centiseconds:02d}"

    def _format_timestamp(self, seconds: float) -> str:
        """Convert seconds to SRT timestamp format"""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        milliseconds = int((seconds % 1) * 1000)

        return f"{hours:02d}:{minutes:02d}:{secs:02d},{milliseconds:03d}"

    def get_ffmpeg_subtitle_filter(self) -> str:
        """
        Generate FFmpeg subtitle filter with style settings
        """
        style_settings = []

        # Font settings
        style_settings.append(f"FontName={self.style['font']}")
        style_settings.append(f"FontSize={self.style['font_size']}")

        # Colors (convert hex to BGR for FFmpeg)
        primary_color = self._hex_to_bgr(self.style['primary_color'])
        if primary_color:
            style_settings.append(f"PrimaryColour={primary_color}")

        # Outline
        if self.style['outline_width'] > 0:
            outline_color = self._hex_to_bgr(self.style['outline_color'])
            if outline_color:
                style_settings.append(f"OutlineColour={outline_color}")
                style_settings.append(f"Outline={self.style['outline_width']}")

        # Position
        if self.style['position'] == 'center':
            style_settings.append("Alignment=2")  # Center
        elif self.style['position'] == 'bottom':
            style_settings.append("Alignment=2")  # Bottom center
            style_settings.append("MarginV=30")

        # Background
        if self.style['background'] == 'black_box':
            style_settings.append("BackColour=&H80000000")
            style_settings.append("BorderStyle=4")
        elif self.style['background'] == 'semi_transparent':
            style_settings.append("BackColour=&H80000000")
            style_settings.append("BorderStyle=3")

        return ",".join(style_settings)

    def _hex_to_bgr(self, hex_color: str) -> Optional[str]:
        """Convert hex color to BGR format for FFmpeg"""
        try:
            if hex_color == 'white':
                return "&HFFFFFF"
            elif hex_color == 'black':
                return "&H000000"
            elif hex_color == 'none':
                return None
            elif hex_color.startswith('#'):
                # Remove # and convert to BGR
                hex_val = hex_color[1:]
                if len(hex_val) == 6:
                    r = int(hex_val[0:2], 16)
                    g = int(hex_val[2:4], 16)
                    b = int(hex_val[4:6], 16)
                    return f"&H{b:02X}{g:02X}{r:02X}"
            return None
        except:
            return None

def create_styled_subtitles(segments: List[Dict], output_path: str, style_name: str = 'modern_purple', output_format: str = 'horizontal') -> str:
    """
    Create stylized subtitles with word-by-word highlighting
    """
    style_manager = CaptionStyleManager(style_name, output_format)
    return style_manager.create_word_level_ass(segments, output_path)

def get_available_caption_styles() -> Dict[str, Dict]:
    """
    Return all available caption styles
    """
    return CaptionStyleManager.CAPTION_STYLES

# Example usage in your tasks.py
def write_styled_clip_srt(segments: List[Dict], srt_path: str, style: str = 'modern_purple'):
    """
    Enhanced version of write_clip_srt with styling support
    """
    # Clamp negative times and filter out invalid segments
    valid_segments = []
    for seg in segments:
        start = max(0, seg["start"])
        end = max(0, seg["end"])
        if end > start and seg["text"].strip():
            valid_segments.append({
                "start": start,
                "end": end,
                "text": seg["text"].strip()
            })

    if not valid_segments:
        logger.warning(f"No valid segments for styled SRT file: {srt_path}")
        return None

    # Create styled subtitles
    create_styled_subtitles(valid_segments, srt_path, style)

    if not os.path.isfile(srt_path):
        raise FileNotFoundError(f"Styled SRT file not found: {srt_path}")

    return srt_path